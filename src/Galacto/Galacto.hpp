//
// NEXT: Add "write opacity" controls for mixing additions to the buffer with existing contents

struct Galacto : Module
{
  uint8_t w = 0;     // w is the output of the equations
  int offset = 0;
  uint8_t previous = 0;
  int t = 0;

  GalactoAudioBuffer galacto_audio_buffer;

  float output = 0;  // output is the audio output

  uint8_t clock_division_counter = 0;
  uint8_t clock_division = 2;

  enum ParamIds {
    CLOCK_DIVISION_KNOB,
    BUFFER_SIZE_KNOB,
    FEEDBACK_KNOB,
		NUM_PARAMS
	};
	enum InputIds {
    AUDIO_INPUT,
    BUFFER_SIZE_INPUT,
		NUM_INPUTS
	};
	enum OutputIds {
    AUDIO_OUTPUT,
    DEBUG_OUTPUT,
		NUM_OUTPUTS
	};
	enum LightIds {
		NUM_LIGHTS
	};

  // Galacto Contructor
	Galacto()
	{
    config(NUM_PARAMS, NUM_INPUTS, NUM_OUTPUTS, NUM_LIGHTS);
    configParam(CLOCK_DIVISION_KNOB, 0.0f, 1.0f, 0.0f, "ClockDivisionKnob");  // 256 gives us the entire range.  Anything after that wraps
    configParam(BUFFER_SIZE_KNOB, 0.0f, 1.0f, 0.0f, "BufferSizeKnob");
    configParam(FEEDBACK_KNOB, 0.0f, 1.0f, 0.0f, "FeedbackKnob");
	}

	// Autosave module data.  VCV Rack decides when this should be called.
	json_t *dataToJson() override
	{
		json_t *root = json_object();
  	return root;
	}

	// Load module data
	void dataFromJson(json_t *root) override
	{
    // There's nothing to save and load yet.
	}


  float calculate_parameter_input(int input_index, int knob_index, float maximum_value)
  {
    float input_value = inputs[input_index].getVoltage() / 10.0; // ranges from 0 to 10
    float knob_value = params[knob_index].getValue(); // ranges from 0 to 128
    float out = 0;

    if(inputs[input_index].isConnected())
    {
      input_value = clamp(input_value, 0.0, 1.0);
      out = clamp((input_value * maximum_value) + knob_value, 0.0, maximum_value);
    }
    else
    {
      out = knob_value;
    }
    return(out);
  }

	void process(const ProcessArgs &args) override
	{

    float buffer_size_input = params[BUFFER_SIZE_KNOB].getValue(); // ranges from 0 to 1
    // unsigned int buffer_size = galacto_audio_buffer.getBufferSize(); // ((float) galacto_audio_buffer.getBufferSize()) * (1.0 - buffer_size_input);
    uint32_t buffer_size = float(galacto_audio_buffer.getMaxBufferSize()) * buffer_size_input;
    galacto_audio_buffer.setBufferSize(buffer_size);

    t += 1;

    galacto_audio_buffer.push(inputs[AUDIO_INPUT].getVoltage());


    // Send the equation, parameters, and expression selections to the "compute"
    // function.  The output of the "compute" function will be a float representing
    // the audio generated by one of the bytebeat equations.
    // Output ranges from -5 to +5

    // float output = audio_buffer.getOutput(offset) + audio_buffer.getOutput(0);

    float output = galacto_audio_buffer.getOutput((buffer_size / 2) - t) + galacto_audio_buffer.getOutput(t);

    // float output = galacto_audio_buffer.getOutput((buffer_size / 2) - t);
    outputs[DEBUG_OUTPUT].setVoltage(buffer_size);
    outputs[AUDIO_OUTPUT].setVoltage(output);
  }




  //
  // compute(...)
  //

  float compute(uint32_t t)
  {
    offset = ((t*7)&(t/14)) * .1;

    // w = (sample(t) + sample(t * .96) + sample(t * .94) + sample((44100 * 2) - t));

    // previous = w;


    w = sample(t + offset) ;

    // w is a 8-bit unsigned integer that ranges from 0 to 256. But
    // this funtion is supposed to return a float between 0 and 1, so we divide
    // w by 256.0.
    return(w / 64.0);
  }

  //
  // These are safe versions of / and %  that avoid division by 0 which crash VCV Rack
  //

  uint32_t div(uint32_t a, uint32_t b)
  {
    if(b == 0) return(0);
    return(a / b);
  }

  uint32_t mod(uint32_t a, uint32_t b)
  {
    if(b == 0) return(0);
    return(a % b);
  }

  int32_t sample(int32_t t)
  {
    int st = t % (OHATMAZEO_SAMPLES-1);
    return(OHATMAZEO[st] >> 4);
  }

};
