//
// NEXT: Add purge buffer
// Use discrete inputs for sample selection
// code in CV control
//

struct Galacto : Module
{
  uint8_t w = 0;     // w is the output of the equations
  int offset = 0;
  uint8_t previous = 0;
  int t = 0;
  unsigned int selected_effect = 0;

  GalactoAudioBuffer galacto_audio_buffer;

  dsp::SchmittTrigger purge_button_schmitt_trigger;

  float output = 0;  // output is the audio output

  uint32_t buffer_size = 0;
  float feedback = 0.0;

  enum ParamIds {
    CLOCK_DIVISION_KNOB,
    BUFFER_SIZE_KNOB,
    FEEDBACK_KNOB,
    EFFECT_KNOB,
    PARAM_1_KNOB,
    PARAM_2_KNOB,
    PURGE_BUTTON,
		NUM_PARAMS
	};
	enum InputIds {
    AUDIO_INPUT,
    EFFECT_INPUT,
    BUFFER_SIZE_INPUT,
    FEEDBACK_INPUT,
    PARAM_1_INPUT,
    PARAM_2_INPUT,
		NUM_INPUTS
	};
	enum OutputIds {
    AUDIO_OUTPUT,
    DEBUG_OUTPUT,
		NUM_OUTPUTS
	};
	enum LightIds {
		NUM_LIGHTS
	};

  // Galacto Contructor
	Galacto()
	{
    config(NUM_PARAMS, NUM_INPUTS, NUM_OUTPUTS, NUM_LIGHTS);

    configParam(PARAM_1_KNOB, 0.0f, 1.0f, 0.0f, "ParamKnob1");
    configParam(PARAM_2_KNOB, 0.0f, 1.0f, 0.0f, "ParamKnob2");

    configParam(BUFFER_SIZE_KNOB, 0.0f, 1.0f, 0.0f, "BufferSizeKnob");
    configParam(FEEDBACK_KNOB, 0.0f, 1.0f, 0.0f, "FeedbackKnob");
    configParam(EFFECT_KNOB, 0.0f, 1.0f, 0.0f, "EffectKnob");

    galacto_audio_buffer.purge();
	}

	// Autosave module data.  VCV Rack decides when this should be called.
	json_t *dataToJson() override
	{
		json_t *root = json_object();
  	return root;
	}

	// Load module data
	void dataFromJson(json_t *root) override
	{
    // There's nothing to save and load yet.
	}


  float calculate_attenuverter_input(int input_index, int knob_index, float min_value, float max_value)
  {
    float input_value = inputs[input_index].getVoltage(); // -10 to 10, normally
    float knob_value = params[knob_index].getValue(); // 0 to 1

    // knob + CV input then clipped
    // CV input ranging from -1 to 1

    // TODO: Code this

    /*
    float input_value = inputs[input_index].getVoltage();
    float knob_value = params[knob_index].getValue();
    float out = 0;

    if(inputs[input_index].isConnected())
    {
      out = clamp((input_value * knob_value), 0.0, maximum_value);
    }
    else
    {
      out = knob_value;
    }
    return(out);
    */
  }

	void process(const ProcessArgs &args) override
	{
    float param_1_input = params[PARAM_1_KNOB].getValue(); // ranges from 0 to 1
    float param_2_input = params[PARAM_2_KNOB].getValue(); // ranges from 0 to 1

    bool purge_button_is_triggered = purge_button_schmitt_trigger.process(params[PURGE_BUTTON].getValue());
    if(purge_button_is_triggered) galacto_audio_buffer.purge();

    //
    // Read buffer and feedback knobs and apply them to the ring buffer
    //
    buffer_size = params[BUFFER_SIZE_KNOB].getValue() * MAX_BUFFER_SIZE;
    feedback = params[FEEDBACK_KNOB].getValue();

    galacto_audio_buffer.setBufferSize(buffer_size);
    galacto_audio_buffer.setFeedback(feedback);

    //

    selected_effect = params[EFFECT_KNOB].getValue() * 7;

    float audio_input = inputs[AUDIO_INPUT].getVoltage();
    float output = 0.0;

    galacto_audio_buffer.push(audio_input);

    switch(selected_effect) {
      case 0:
        output = eye_1(audio_input, param_1_input, param_2_input);
        break;
      case 1:
        output = eye_2(audio_input, param_1_input, param_2_input);
        break;
      case 2:
        output = eye_3(audio_input, param_1_input, param_2_input);
        break;
      case 3:
        output = eye_4(audio_input, param_1_input, param_2_input);
        break;
      case 4:
        output = eye_5(audio_input, param_1_input, param_2_input);
        break;
      case 5:
        output = eye_6(audio_input, param_1_input, param_2_input);
        break;
      case 6:
        output = eye_7(audio_input, param_1_input, param_2_input);
        break;
      case 7:
        output = eye_8(audio_input, param_1_input, param_2_input);
        break;
    }

    outputs[AUDIO_OUTPUT].setVoltage(output);
  }

  float eye_1(float audio_input, float p1, float p2)
  {
    t += 1;

    float output = galacto_audio_buffer.getOutput((buffer_size / 2) - t) + galacto_audio_buffer.getOutput(t);

    return(output);
  }

  float eye_2(float audio_input, float p1, float p2)
  {
    t += 1;

    // Send the equation, parameters, and expression selections to the "compute"
    // function.  The output of the "compute" function will be a float representing
    // the audio generated by one of the bytebeat equations.
    // Output ranges from -5 to +5

    // Removed for testing:
    float output = galacto_audio_buffer.getOutput(t) + galacto_audio_buffer.getOutput(t + (buffer_size / 2)) + galacto_audio_buffer.getOutput(t + (buffer_size / 4));

    return(output);
  }

  float eye_3(float audio_input, float p1, float p2)
  {
    t += 1;

    uint32_t vp2 = p2 * 16.0;

    offset = ((t*7)&div(t,vp2)) * .1;

    float output = galacto_audio_buffer.getOutput(t + offset);

    return(output);
  }


  float eye_4(float audio_input, float p1, float p2)
  {
    t += 1;

    uint32_t vp2 = p2 * 32.0;
    uint32_t vp1 = p1 * 32.0;

    offset = ((t*vp1)&div(t,vp2)) * .1;

    float output = galacto_audio_buffer.getOutput(t + offset);

    return(output);
  }


  float eye_5(float audio_input, float p1, float p2)
  {
    t += 1;

    uint32_t vp2 = p2 * 32.0;
    uint32_t vp1 = p1 * 32.0;

    // offset = (div(t,vp2),(t*vp1)) * .1;

    offset = ((t >> vp1) & t) * (t>>vp2);

    float output = galacto_audio_buffer.getOutput(t + offset);

    return(output);
  }

  float eye_6(float audio_input, float p1, float p2)
  {
    t += 1;

    uint32_t vp2 = p2 * 32.0;
    uint32_t vp1 = p1 * 32.0;

    // offset = (div(t,vp2),(t*vp1)) * .1;

    offset = mod((( mod(t,((76 - (t>>vp2)) % 11))) * (t>>1)), (47-(t>>(4+vp1)) % 41)) * .7;

    float output = galacto_audio_buffer.getOutput(t + offset);

    return(output);
  }


  float eye_7(float audio_input, float p1, float p2)
  {
    t += 1;

    uint32_t vp1 = p1 * 128;
    uint32_t vp2 = p2 * 15;

    offset = (vp1&t*(4|(7&t>>13))>>(1&-t>>vp2))+(127&t*(t>>11&t>>13)*(3&-t>>9));

    float output = galacto_audio_buffer.getOutput(t + offset);

    return(output);
  }

  float eye_8(float audio_input, float p1, float p2)
  {
    t += 1;

    uint32_t vp1 = p1 * 128;
    uint32_t vp2 = p2 * 15;

    offset = 1;

    float output = galacto_audio_buffer.getOutput(t + offset);

    return(output);
  }

  //
  // These are safe versions of / and %  that avoid division by 0 which crash VCV Rack
  //

  uint32_t div(uint32_t a, uint32_t b)
  {
    if(b == 0) return(0);
    return(a / b);
  }

  uint32_t mod(uint32_t a, uint32_t b)
  {
    if(b == 0) return(0);
    return(a % b);
  }

};
