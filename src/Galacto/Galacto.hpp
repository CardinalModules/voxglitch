//
// NEXT: Add "write opacity" controls for mixing additions to the buffer with existing contents

struct Galacto : Module
{
  uint8_t w = 0;     // w is the output of the equations
  int offset = 0;
  uint8_t previous = 0;
  int t = 0;
  unsigned int selected_effect = 0;

  GalactoAudioBuffer galacto_audio_buffer;

  float output = 0;  // output is the audio output

  uint32_t buffer_size = 0;
  float feedback = 0.0;

  enum ParamIds {
    CLOCK_DIVISION_KNOB,
    BUFFER_SIZE_KNOB,
    FEEDBACK_KNOB,
    EFFECT_KNOB,
    PARAM_KNOB_1,
    PARAM_KNOB_2,
		NUM_PARAMS
	};
	enum InputIds {
    AUDIO_INPUT,
    BUFFER_SIZE_INPUT,
		NUM_INPUTS
	};
	enum OutputIds {
    AUDIO_OUTPUT,
    DEBUG_OUTPUT,
		NUM_OUTPUTS
	};
	enum LightIds {
		NUM_LIGHTS
	};

  // Galacto Contructor
	Galacto()
	{
    config(NUM_PARAMS, NUM_INPUTS, NUM_OUTPUTS, NUM_LIGHTS);

    configParam(PARAM_KNOB_1, 0.0f, 1.0f, 0.0f, "ParamKnob1");
    configParam(PARAM_KNOB_2, 0.0f, 1.0f, 0.0f, "ParamKnob2");

    configParam(BUFFER_SIZE_KNOB, 0.0f, 1.0f, 0.0f, "BufferSizeKnob");
    configParam(FEEDBACK_KNOB, 0.0f, 1.0f, 0.0f, "FeedbackKnob");
    configParam(EFFECT_KNOB, 0.0f, 1.0f, 0.0f, "EffectKnob");
	}

	// Autosave module data.  VCV Rack decides when this should be called.
	json_t *dataToJson() override
	{
		json_t *root = json_object();
  	return root;
	}

	// Load module data
	void dataFromJson(json_t *root) override
	{
    // There's nothing to save and load yet.
	}


  float calculate_parameter_input(int input_index, int knob_index, float maximum_value)
  {
    float input_value = inputs[input_index].getVoltage() / 10.0; // ranges from 0 to 10
    float knob_value = params[knob_index].getValue(); // ranges from 0 to 128
    float out = 0;

    if(inputs[input_index].isConnected())
    {
      input_value = clamp(input_value, 0.0, 1.0);
      out = clamp((input_value * maximum_value) + knob_value, 0.0, maximum_value);
    }
    else
    {
      out = knob_value;
    }
    return(out);
  }

	void process(const ProcessArgs &args) override
	{
    /*
    t += 1;

    float param_1_input = params[BUFFER_SIZE_KNOB].getValue(); // ranges from 0 to 1
    float param_2_input = params[FEEDBACK_KNOB].getValue(); // ranges from 0 to 1

    uint32_t buffer_size = float(galacto_audio_buffer.getMaxBufferSize()) * param_1_input;


    galacto_audio_buffer.setBufferSize(buffer_size);
    galacto_audio_buffer.setFeedback(param_2_input);



    galacto_audio_buffer.push(inputs[AUDIO_INPUT].getVoltage());


    // Send the equation, parameters, and expression selections to the "compute"
    // function.  The output of the "compute" function will be a float representing
    // the audio generated by one of the bytebeat equations.
    // Output ranges from -5 to +5

    // Removed for testing:
    float output = galacto_audio_buffer.getOutput((buffer_size / 2) - t) + galacto_audio_buffer.getOutput(t);
    */

    float param_1_input = params[PARAM_KNOB_1].getValue(); // ranges from 0 to 1
    float param_2_input = params[PARAM_KNOB_2].getValue(); // ranges from 0 to 1

    //
    // Read buffer and feedback knobs and apply them to the ring buffer
    //
    buffer_size = params[BUFFER_SIZE_KNOB].getValue() * MAX_BUFFER_SIZE;
    feedback = params[FEEDBACK_KNOB].getValue();

    galacto_audio_buffer.setBufferSize(buffer_size);
    galacto_audio_buffer.setFeedback(feedback);

    //

    selected_effect = params[EFFECT_KNOB].getValue() * 6;

    float audio_input = inputs[AUDIO_INPUT].getVoltage();
    float output = 0.0;

    galacto_audio_buffer.push(audio_input);

    switch(selected_effect) {
      case 0:
        output = eye_1(audio_input, param_1_input, param_2_input);
        break;
      case 1:
        output = eye_2(audio_input, param_1_input, param_2_input);
        break;
      case 2:
        output = eye_3(audio_input, param_1_input, param_2_input);
        break;
      case 3:
        output = eye_4(audio_input, param_1_input, param_2_input);
        break;
      case 4:
        output = eye_5(audio_input, param_1_input, param_2_input);
        break;
      case 5:
        output = eye_6(audio_input, param_1_input, param_2_input);
        break;
      case 6:
        output = eye_7(audio_input, param_1_input, param_2_input);
        break;
    }

    outputs[AUDIO_OUTPUT].setVoltage(output);
  }

  float eye_1(float audio_input, float p1, float p2)
  {
    t += 1;

    // Send the equation, parameters, and expression selections to the "compute"
    // function.  The output of the "compute" function will be a float representing
    // the audio generated by one of the bytebeat equations.
    // Output ranges from -5 to +5

    // Removed for testing:
    float output = galacto_audio_buffer.getOutput((buffer_size / 2) - t) + galacto_audio_buffer.getOutput(t);

    return(output);
  }

  float eye_2(float audio_input, float p1, float p2)
  {
    t += 1;

    // Send the equation, parameters, and expression selections to the "compute"
    // function.  The output of the "compute" function will be a float representing
    // the audio generated by one of the bytebeat equations.
    // Output ranges from -5 to +5

    // Removed for testing:
    float output = galacto_audio_buffer.getOutput(t) + galacto_audio_buffer.getOutput(t + (buffer_size / 2)) + galacto_audio_buffer.getOutput(t + (buffer_size / 4));

    return(output);
  }

  float eye_3(float audio_input, float p1, float p2)
  {
    t += 1;

    uint32_t vp2 = p2 * 16.0;

    offset = ((t*7)&div(t,vp2)) * .1;

    float output = galacto_audio_buffer.getOutput(t + offset);

    return(output);
  }


  float eye_4(float audio_input, float p1, float p2)
  {
    t += 1;

    uint32_t vp2 = p2 * 32.0;
    uint32_t vp1 = p1 * 32.0;

    offset = ((t*vp1)&div(t,vp2)) * .1;

    float output = galacto_audio_buffer.getOutput(t + offset);

    return(output);
  }


  float eye_5(float audio_input, float p1, float p2)
  {
    t += 1;

    uint32_t vp2 = p2 * 32.0;
    uint32_t vp1 = p1 * 32.0;

    // offset = (div(t,vp2),(t*vp1)) * .1;

    offset = ((t >> vp1) & t) * (t>>vp2);

    float output = galacto_audio_buffer.getOutput(t + offset);

    return(output);
  }

  float eye_6(float audio_input, float p1, float p2)
  {
    t += 1;

    uint32_t vp2 = p2 * 32.0;
    uint32_t vp1 = p1 * 32.0;

    // offset = (div(t,vp2),(t*vp1)) * .1;

    offset = mod((( mod(t,((76 - (t>>vp2)) % 11))) * (t>>1)), (47-(t>>(4+vp1)) % 41)) * .7;

    float output = galacto_audio_buffer.getOutput(t + offset);

    return(output);
  }


  float eye_7(float audio_input, float p1, float p2)
  {
    t += 1;

    // offset = (div(t,vp2),(t*vp1)) * .1;

    float output = galacto_audio_buffer.getOutput(t-10) + galacto_audio_buffer.getOutput(t-20);


    return(output);
  }

  //
  // compute(...)
  //

  float compute(uint32_t t)
  {
    offset = ((t*7)&(t/14)) * .06;

    // w = (sample(t) + sample(t * .96) + sample(t * .94) + sample((44100 * 2) - t));

    // previous = w;


    w = sample(t + offset) ;

    // w is a 8-bit unsigned integer that ranges from 0 to 256. But
    // this funtion is supposed to return a float between 0 and 1, so we divide
    // w by 256.0.
    return(w / 64.0);
  }

  //
  // These are safe versions of / and %  that avoid division by 0 which crash VCV Rack
  //

  uint32_t div(uint32_t a, uint32_t b)
  {
    if(b == 0) return(0);
    return(a / b);
  }

  uint32_t mod(uint32_t a, uint32_t b)
  {
    if(b == 0) return(0);
    return(a % b);
  }

  int32_t sample(int32_t t)
  {
    int st = t % (OHATMAZEO_SAMPLES-1);
    return(OHATMAZEO[st] >> 4);
  }

};
